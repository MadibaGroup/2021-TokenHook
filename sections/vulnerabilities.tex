% !TEX root = ../main.tex

\section{Sample of high profile vulnerabilities}\label{sec:vul}
In this section, we sample some high profile vulnerabilities, typically ones that have been exploited in real world \erc tokens\cite{SolidtySecBlog,EthSecServ,SoliditySecCon,ConsensysSecCon,LandoKL}. For each, we (i) briefly explain technical details, (ii) the ability to affect \erc tokens, and (iii) discuss mitigation techniques. 
%Later we will compile a more comprehensive list of \num vulnerabilities and best practices (see Table\ref{tab:result1}), including these, however space will not permit us to discuss each one at the same level of detail as the ones we highlight in this section (however we will include a simple statement describing the issue and the mitigation).

\subsection{Multiple withdrawal}\label{subsec:mwa}

This \erc-specific issue was originally raised in 2017\cite{MikVlad,TomHale}. It can be considered as a \textit{transaction-ordering}\cite{OrderingAttack} or \textit{front-running}\cite{eskandari2019sok} attack. There are two \erc functions (\ie \texttt{Approve()} and \texttt{transferFrom()}) that can be used to authorize a third party for transferring tokens on behalf of someone else. Using these functions in an undesirable situation (\ie front-running or race-condition) can result in allowing a malicious authorized entity to transfer more tokens than the owner wanted. There are several suggestions to extend \erc standard (\eg MonolithDAO\cite{MonolithDAO} and its extension in OpenZeppelin\cite{OpenZepplin}) by adding new functions (\ie \texttt{decreaseApproval()} and \texttt{increaseApproval()}), however, securing \texttt{transferFrom()} method is the effective one while adhering specifications of the \erc standard\cite{ERC20MWA}.

\subsection{Arithmetic Over/Under Flows.}\label{subsec:ovf}
An \textit{integer overflow} is a well known issue in many programming languages. For \erc, one notable exploit was in April 2018 that targeted the BEC Token\cite{BECToken} and resulted in some exchanges (\eg OKEx, Poloniex and HitBTC) suspending deposits and withdrawals of all tokens. Although BEC developers had considered most of the security measurements, only line 261 was vulnerable\cite{Osiris}\cite{PeckShield}. The attacker was able to pass a combination of input values to transfer large amount of tokens\cite{Overflow}. It was even larger than the initial supply of the token, allowing the attacker to take control of token financing and manipulate the price. In Ethereum, integer overflows do not throw an exception at runtime. This is by design and can be prevented by using the \texttt{SafeMath} library\cite{SafeMath} wherein \texttt{a+b} will be replaced by \texttt{a.add(b)} and throws an exception in the case of arithmetic overflow.

\subsection{Re-entrancy}\label{subsec:ent}
One of the most studied vulnerabilities is re-entrancy, which resulted in a US\$50M attack on a DApp (called the DAO) in 2016 and triggered an Ethereum hard-fork to revert\cite{DAO1}. At first glance, re-entrancy might seem inapplicable to \erc however any function that changes internal state, such as balances, need to be checked. Further, some \erc extensions could also be problematic. One example is ORBT tokens~\cite{ORBTToken} which support token exchange with ETH without going through a crypto-exchange~\cite{ORBT}: an attacker can call the exchange function to sell the token and get back equivalent in ETH. However, if the ETH is transferred in a vulnerable way before reaching the end of the function and updating the balances, control is transferred to the attacker receiving the funds and the same function could be invoked over and over again within the limits of a single transaction, draining excessive ETH from the token contract. This variant of the attack is known as \textit{same-function re-entrancy}, but it has three other variants: \textit{cross-function}, \textit{delegated} and \textit{create-based} \cite{SEREUM}. Mutex~\cite{WiKiMutex} and CEI~\cite{SolidtyDocSec} techniques can be used to prevent it. In Mutex, a state variable is used to lock/unlock transferred ETH by the lock owner (\ie token contract). The lock variable fails subsequent calls until finishing the first call and changing requester balance. CEI updates the requester balance before transferring any fund. All interactions (\ie external calls) happen at the end of the function and prevents recursive calls. Although CEI does not require a state variable and consumes less Gas, developers must be careful enough to update balances before external calls. Mutex is more efficient and blocks \textit{cross-function} attacks at the beginning of the function regardless of internal update sequences. CEI can also be considered as a best practice and basic mitigation for the \textit{same-function re-entrancy}

\subsection{Unchecked return values}\label{subsec:urv}
In Solidity, sending ETH to external addresses is supported by three options: \texttt{call.value()}, \texttt{transfer()}, or \texttt{send()}. The \texttt{transfer()} method reverts all changes if the external call fails, while the other two return a boolean value and manual check is required to revert transaction to the initial state\cite{SoliditySendEther}. Before the \textit{Istanbul} hard-fork\cite{IstanbulUpgrades}, \texttt{transfer()} was the preferred way of sending ETH. It mitigates reentry by ensuring ETH recipients would not have enough gas (\ie a 2300 limit) to do anything meaningful beyond logging the transfer when execution control was passed to them. EIP-1884\cite{EIP1884} has increased the gas cost of some opcodes that causes issues with \texttt{transfer()}\footnote{After \textit{Istanbul}, the \texttt{fallback()} function consumes more than 2300 Gas if called via \texttt{transfer()} or \texttt{send()} methods.}. This has led to community advice to use \texttt{call.value()} and rely on one of the above re-entrancy mitigations (\ie Mutex or CEI)\cite{ConsensysStopTran,ChainSecurity}.

\subsection{Frozen Ether}\label{subsec:feth}

As \erc tokens can receive and hold ETH, just like a user accounts, functions need to be defined to withdraw deposited ETH (including unexpected ETH). If these functions are not defined correctly, an \erc token might hold ETH with no way of recovering it (\cf Parity Wallet\cite{ParityWalletHack}). If necessary, developers can require multiple signatures to withdraw ETH.

\subsection{Unprotected Ether Withdrawal}\label{subsec:uew}

Improper access control may allow unauthorized persons to withdraw ETH from smart contracts (\cf Rubixi\cite{Rubixi}). Therefore, withdrawals must be triggered by only authorized accounts and ideally multiple parties.

\subsection{State variable manipulation}\label{subsec:svm}

The \texttt{DELEGATECALL} opcode in Ethereum enables a DApp to invoke external functions of other DApps and execute them in the context of calling contract (\ie the invoked function can modify the state variables of the caller). This makes it possible to deploy libraries once and reuse the code in different contracts. However, the ability to manipulate internal state variables by external functions has lead to incidents where the entire contract was hijacked (\cf the second hack of Parity MultiSig Wallet\cite{ParitySecondHack}). Preventive techniques is to use \texttt{Library} keyword in Solidity to force the code to be stateless, where data is passed as inputs to functions and passed back as outputs and no internal storage is permitted\cite{LIB1}. There are two types of Library: \textit{Embedded} and \textit{Linked}. Embedded libraries have only internal functions (EVM uses \texttt{JUMP} opcode instead of \texttt{DELEGATECALL}), in contrast to linked libraries that have public or external functions (EVM initiate a ``message call''). Deployment of linked libraries generates a unique address on the blockchain while the code of embedded libraries will be added to the contract's code \cite{LIB2}. It is recommended to use Embedded libraries to mitigate this attack.

\subsection{Public visibility}\label{subsec:pvis}

In Solidity, visibility of functions are \texttt{Public} by default and they can be called by any external user/contract. In the Parity MultiSig Wallet hack\cite{ParityFirstHack}, an attacker was able to call public functions and reset the ownership address of the contract, triggering a \$31M USD theft. It is recommended to explicitly specify visibility of functions instead of default \texttt{Public} visibility.


%\subsection{Balance manipulation}\label{subsec:blman}
%
%\erc tokens generally receive ETH via a \textit{payable} function\cite{SolidityDocPayable} (\ie \texttt{receive()}, \texttt{fallback()}, \etc), however, it is possible to send ETH without triggering payable functions, for example via \texttt{selfdestruct()} that is initiated by another contract\cite{SolidityByExampleSelfDestruct}. This can cause an oversight where \erc may not properly account for the amount of ETH they have received\cite{UnexpectedEth}. For example, A contract might use ETH balance to calculate exchange rate dynamically. Forcing ETH by attacker may affect calculations and get lower exchange rate. To fortify this vulnerability, contract logic should avoid using exact values of the contract balance and keep track of the known deposited ETH by a new state variable. Although we use \texttt{address(this).balance} in \sys, we do not check the exact value of it (\ie \texttt{address(this).balance == 0.5 ether)}---we only check whether the contract has enough ETH to send out or not. Therefore, there is no need to use a new state variable and consume more Gas to track contract's ETH. However, for developers who need to track it manually, we provide \texttt{contractBalance} variable. Two complementary functions are also considered to get current contract balance and check unexpected received ETH (\ie \texttt{getContractBalance()} and \texttt{unexpectedEther()}).
%
%\subsection{Unprotected SELFDESTRUCT}\label{subsec:slfd}
%
%Another vulnerability stemming from the second Parity wallet attack\cite{ParitySecondHack} is protecting the \texttt{SELFDESTRUCT} opcode which removes a contract from Ethereum. The self-destruct method is used to kill the contract and its associated storage. \erc tokens should not contain \texttt{SELFDESTRUCT} opcode unless there is a multi approval mechanism.
%
